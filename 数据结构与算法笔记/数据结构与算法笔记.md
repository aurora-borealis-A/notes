# 一、绪论

数据结构**组成**：

- 数据的**逻辑结构**
  - 线性结构
    - 线性表；
    - 栈（特殊线性表）；
    - 队列（特殊线性表）；
    - 字符串、数组、广义表。
  - 非线性结构
    - 树形结构；
    - 图形结构。
- 数据的**存储结构**
  - 顺序存储；
  - 链式存储。
- 数据的运算
  - 检索、排序、插入、删除、修改等。





# 二、线性表

## 1.定义

　　线性表是具有**相同特性**的数据元素的一个有限序列。

**相关概念：**

- 线性起点（也叫“起始结点”）：线性表中第一个数据元素；
- 直接前趋：线性表中一个数据元素的前一个数据元素；
- 直接后继：线性表中一个数据元素的后一个数据元素；
- 线性终点（也叫“终端结点”）：线性表中最后一个数据元素。

**线性表特点：**

- 在非空的线性表中，有且仅有一个开始结点a~1~，它没有直接前趋，而仅有一个直接后继a~2~；
- 有且仅有一个终端结点a~n~，它没有直接后继，而仅有一个直接前趋a~n-1~；
- 其余的內部结点a~i~（2 ≤ i ≤ n-1）都有且仅有一个直接前趋a~i-1~和一个直接后继a~i+`~。

**注意**：

- 线性表数据元素的下标是从1开始的，而**不是从零开始**。
- **线性起点**只有直接后继，**没有直接前趋**。
- **线性终点**只有直接前趋，**没有直接后继**。
- 线性表中长度为0时，成为**空表**。



## 2.基本操作

- InitList(&L)
  - 操作结果：构造一个空的线性表。
- DestroyList(&L)
  - 初始条件：线性表L已经存在；
  - 操作结果：销毁一个线性表。
- ClearList(&L)：
  - 初始条件：线性表L已经存在；
  - 操作结果：将线性表重置为空表。

---

- ListEmpty(L)
  - 初始条件：线性表L已经存在；
  - 操作结果：如哦线性表为空表，则返回True；否则返回False。
- LsitLength(L)
  - 初始条件：线性表L已经存在；
  - 操作结果：返回线性表L中的数据元素的个数（返回线性表长度）。

---

- GetElem(L, i, &e)
  - 初始条件：线性表L已经存在，且1 ≤ i ≤ ListLength(L)；
  - 操作结果：用e返回线性表中第i个数据元素的值。

- LocateElem(L, e, compare())
  - 初始条件：线性表L已经存在，compare()是数据元素判定函数；
  - 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0.

---

- PriorElem(L, cur_e, &pre_e)
  - 初始条件：线性表L已经存在；
  - 操作结果：若cur_e是L的数据元素，且不是第一个，则pre_e返回它的前趋；否则操作失败，pre_e无意义。
- NextElem(L, cur_e, &next_e)
  - 初始条件：线性表L已经存在；
  - 操作结果：若cur_e是L的数据元素，且不是最后一个，则next_e返回它的后继；否则操作失败，next_e无意义。

---

- ListInsert(&L, i, e)
  - 初始条件：线性表L已经存在，1 ≤ i ≤ ListLength(L)+1；
  - 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1。

- ListDelete(&L, i, &e)
  - 初始条件：线性表L已经存在，1 ≤ i ≤ ListLength(L)；
  - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1。

---

- ListTraverse(&L, visited())
  - 初始条件：线性表L已经存在；
  - 操作结果：依次对线性表中每个元素调用visted()，即：遍历每个元素，并对每个元素操作。



## 3.顺序表

### 3.1 定义

　　顺序表存储定义：把**逻辑上相邻**的数据元素存储在**物理上相邻**的存储单元中。

　　线性表的顺序表示又称为**顺序存储结构**或**顺序映像**。

**注意：**

- 线性表顺序存储结构占用一片连续的存储空间。
- 知道某个元素的存储位置就可以计算其他元素的存储位置。

### 3.2 顺序表存储结构定义

顺序表存储结构类型包含了两部分：

- 数据元素数组；
- 数据元素数组的长度（线性表的长度）。

```c++
#defien MAXSIZE 1000  // 线性表的上限大小

typedef struct{
    ElemType *elem;  // 或者 ElemType elem[MAXSIZE]
    int length;
}SqList;
```

### 3.3 一些算法中的宏定义

```c++
// 函数结果状态宏定义
#define TRUE 	1
#define FALSE 	0
#define OK 		1
#define ERROR 	0
#define INFEASIBILE -1
#define OVERFLOW	-2

// Status 是函数的类型，其值是函数结果的状态代码
typedef int Status;
```



### 3.4 顺序表基本操作的实现

#### 3.4.1 初始化顺序表

- 开辟数组空间；
- 表长记为0。

```c++
Status InitList_Sq(SqList &L){
	L.elem = new ElemType[MAXSIZE];
    if(!L.elem) exit(OVERFLOW);
    L.length=0;
    return OK;
}
```

#### 3.4.2 销毁顺序表

销毁顺序表的数组，释放内存。

```c++
void DestroyList_Sq(SqList &L){
    if (L.elem) delete L.elem;
}
```

#### 3.4.3 清空顺序表

将顺序表的长度记为0，即代表空表。

```c++
void ClearList_Sq(Sqlist &L){
	L.length = 0;
}
```

#### 3.4.4 顺序表是否为空

判断表厂是否为0。

```c++
int ListEmpty_Sq(Sqlist &L){
    if (L.length==0) return 1;
    else return 0;
}
```

#### 3.4.5 顺序表长度

返回表厂。

```c++
int ListLength_Sq(Sqlist &L){
    return L.length;
}
```

#### 3.4.6 顺序表取值

按照数据元素的下标，对数组进行索引。

```c++
Status GetElem_Sq(Sqlist &L, int i, ElemType &e){
    if (i<1 || i>L.length) return ERROR;
    e = L.elem[i-1];
    return OK;
}
```

#### 3.4.7 顺序表查找（已知元素找下标）

顺序比较数据元素，如果相同就返回下标。

```c++
int LocateElem_Sq(Sqlist &L, ElemType e){
    for(int i=0;i < L.legnth;i++){
        if (L.elem[i] == e) return i+1;  // 返回数据元素下标（数据元素下标比数组下标大1）
    return 0;  // 查找失败，返回0
}
```

或者

```c++
int LocateElem(Sqlist &L, ElemType e){
    int i = 0;
	while(L.elem[i++] != e && i<L.length);  // 开始查找，找到停止，i用于记录找到的元素的下标
    if (i >= L.length) return 0;
    else return i;
}
```

#### 3.4.8 顺序表插入

先依次将插入位置之后的数据元素向后移动，再插入新的数据元素，而后表长+1。

```c++
Status ListInsert_Sq(Sqlist &L, int i, ElemType e){
    if(i<1 || i>L.length+1) return ERROR;  // 判断插入位置是否合法
    if(L.length == MAXSIZE) return ERROR;  // 判断存储空间是否已满
    for(int j=L.length+1;j >= i;j--)
        L.elem[j] = L.elem[j-1];  // 依次将插入位置之后的数据元素向后移动
    L.elem[i-1] = e;  // 插入新的数据元素
    L.legnth ++;  // 顺序表长+1
    return OK;
    }
}
```

#### 3.4.9 顺序表删除

```c++
Status ListDelete_Sq(Sqlist &L, int i){
	if (i<1 || i > L.length)  return ERROR;  // 判断删除下标是否合法
    for(j=i;j<L.length-1;j++)
        L.elem[j-1] = L.elem[j];  // 依次将被删元素之后的数据向前移动
	L.length--;  // 顺序表长-1
    return OK;
}
```



## 4.链表

### 4.1 定义

　　结点再存储器中的位置是任意的，即**逻辑上相邻**的数据元素**在物理上不一定相邻**。

　　线性表的链式表示又称为**非顺序映像**或**链式映像**。

---

**特点：**

- 用一组**物理位置任意**的存储单元来存放线性表的数据元素。
- 这组存储单元既可以是连续的，也可以**是不连续**的，甚至是**零散分布**在内存中的任意位置的。
- 链表中元素的**逻辑次序和物理次序不一定相同**。

---

**相关概念：**

- 结点：数据元素的存储映像。由**数据域**和**指针域**组成。
- 链表：n个结点由指针链组成一个链表。
  - 它是线性表的链式存储映像，称为线性表的链式存储结构。

---

**链表组成：**

- 头指针：指向链表中第一个结点的指针。
- 头结点：链表首元结点之前附设的一个结点，它**不存储数据元素**（或者存储链表长度等附加信息），只是为了链表处理的方便。
- 首元结点：链表中存储第一个数据元素a~1~的结点。

---

**链表种类**：

- 单链表：单个结点只有一个指针域的链表。
- 双链表：单个结点有两个指针与的链表。
- 循环链表：首位相接的链表，即尾结点的指针域指向头结点。

**注意：**

- 链表可以带头结点，也可以不带头结点。一般都是带头节结点。
- 头结点不计入链表长度。

---

**空表定义：**

- 无头结点时，**头指针为空**时表示空表。
- 有头结点时，**头结点的指针域为空**时代表空表。

### 4.2单链表存储结构定义

```c++
typedef struct Lnode{
    ElemType data;
    struct Lnode *next;
}LNode, *LinkList
```

### 4.3单链表基本操作的实现

#### 4.3.1 单链表初始化

```c++
Status InitList_L(LinkList &L){
    L = new LNode;  // 或 L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    return OK;
}
```

#### 4.3.2 销毁单链表

沿着链表，逐一释放各结点内存。

```c++
Satus ClearList_L(LinkList &L){
    LinkList p;
    while(L){
        p = L;
        L = L->next;
        delete p;
    }
    return OK；
}
```

#### 4.3.3 清空单链表

- 定义辅助指针p,q。p在前，q在后，边顺着链表前进，边删除结点。
- 删除所有数据结点，但保留头结点，并另头结点的指针域为空。

```c++
Status ClearList_L(LinkList &L){
    LinkList p, q;
    p = L->next;  // 指向头结点
    while(p){
        q = p->next;
        delete p;
        p = q;
    }
    L->next = NULL;  // 头结点指针域为空
    return OK;
}
```

#### 4.3.4 单链表是否为空

如果首元结点的指针域不为空，则链表不为空；否则为空表。

```c++
int ListEmpty_L(LinkList &L){
    if (L->next) return 0;
    else return 1;
}
```

#### 4.3.5 单链表长度

遍历链表，统计结点数。

```c++
int ListLength(LinkList &L){
    LinkList p;
    p = L->next;  // 初始指向首元结点
    int i = 0;  // 用于计数
    while(p){
        i++;
        p = p->next;
    }
    return i;
}
```

#### 4.3.6 单链表取值

设置一计数器，每前进一个结点，计数器就加一。

```c++
Status GetElem_L(LinkList &L, int i, ElemType &e){
    LinkList p;
    p = L->next;
    int j = 1;
    while(j++<i && p){
    	p = p->next;   
    }
    if(!p || i<1) return ERROR;  // 如果下标小于1，或者没有找到，返回错误
    e = p->data;
    return OK;
    
}
```

#### 4.3.7 单链表查找

定义辅助指针，初始指向首元结点，并顺着链表找下去。如果找到了或者链表找完了也没找到，就结束查找。

```c++
LinkList LocateElem(LinkList &L, ElemType e){
    LinkList p = L->next;
    while(p && p->data != e){
        p = p->next;
    }
    return p;
}
```

#### 4.3.8 单链表插入

```c++
Status ListInsert_L(LinkList &L, int i, ElemType e){
    LinkList p = L->next;
    int j = 1;
    while(j<i-1 && p){
        p = p->next;
        j++;
    }
    if(i<0 || !p) return ERROR;  // 如果下标小于0，或者找遍了链表也找不到，就返回错误
    
    LinkList s = new Londe;
    s->data = e;  // 创建新结点，并为新结点赋值要插入的数据
    s->next = p->next;  // 插入新结点
    p->next = s;
    return OK;
}
```

#### 4.3.9 单链表删除

```c++
Status ListDelete_L(LinkList &L, int i, ElemType &e){
    LinkList p = L->next;
    int j = 1;
    while(j<i-1 && p->next){
        p = p->next;
        j++;
    }
    if(!p->next || i<0) return ERROR;
    
    LinkList q= p->next;  // 定义指针指向要删除的结点
    p->next = q->next;  // 更新链接关系
    e = q->data;  // 保存要删除结点的数据
    delete q;  // 删除结点，释放内存
    return OK;
}
```

### 4.4 单链表的建立

#### 4.4.1 头插法

将数据（n个结点）依次从**头部插入**，以此来构建一个长度为n的链表。

```c++
void CreateList_H(LinkList &L, int n){
    // 创建一个空表
    L = new LNode;
    L->next = NULL;
    
    for(int i=0;i<n;i++){
        // 创建一个新结点，并赋值数据
        s = new LNode;
        cin >> s->data;
        
        // 在头部插入新数据
        s->next = L->next;
        L->next = s;
    }
}
```

#### 4.4.2 尾插法

将数据（n个结点）依次从**尾部插入**，以此来构建一个长度为n的链表。

```c++
void CreateList_R(LinkList &L, n){
    // 创建一个空表
    L = new LNode;
    L->next = NULL;
    
    // 定义一尾指针，指向尾结点
    LinkList r = L;
    
    for(int i=0;i<n;i++){
        // 创建新结点，并赋值数据
        s = new LNode;
        cin >> s->data;
        
        // 将新结点插入到尾部
        s->next = NULL;  // 尾结点的指针域为空
        r->next = s;
        r = s;
    }
}
```

### 4.5 循环链表

　　循环链表是一种头尾相接的链表（即：表中最后一个结点的指针域指向头结点，整个链表形成一个环）。

---

**特点：**

- 从表中任意结点出发，均可找到表中其他结点。

- 由于**循环链表中没有NULL指针**，因此对链表遍历时，终止条件不能像**非循环链表**那样**判断p或者p->next是否为空**，而是**判断他们是否等于头指针**。

  - |     单链表      |  单循环链表  |
    | :-------------: | :----------: |
    |    p != NULL    |    p != L    |
    | p->next != NULL | p->next != L |

### 4.6 单链表、循环链表和双向链表的时间效率比较

|                                             |           查找首元结点            |               查找表尾结点                |                  查找前趋结点                   |
| :-----------------------------------------: | :-------------------------------: | :---------------------------------------: | :---------------------------------------------: |
|            带头结点的**单链表**             |    L->next<br />时间复杂度O(1)    | 从L->next依次向后遍历<br />时间复杂度O(n) |                无法找到前趋结点                 |
| 带头结点的**仅设头指针L**<br />的循环单链表 |    L->next<br />时间复杂度O(1)    | 从L->next依次向后遍历<br />时间复杂度O(n) | 通过p->next可以找到前趋结点<br />时间复杂度O(n) |
| 带头结点的**仅设尾指针R**<br />的循环单链表 | R->next->next<br />时间复杂度O(1) |           R<br />时间复杂度O(1)           | 通过p->next可以找到前趋结点<br />时间复杂度O(n) |
|         带头结点的**双向循环链表**          |    L->next<br />时间复杂度O(1)    |       L->prior<br />时间复杂度O(1)        |          p->prior<br />时间复杂度O(1)           |

### 4.7 链式存储结构的优缺点

**存储密度：**

　　存储密度是指结点**数据**本身所占的存储量和**整个结点**结构所占的存储量之比，即：

> 存储密度 = 结点数据本身占用 / 结点占用的空间总量

- 链表的存储密度较低，小于１；
- 顺序表的存储密度最大，等于1（100%）。

---

**优点：**

- 结点空间可以**动态申请和释放**；
- 数据元素的逻辑次序（逻辑结构）靠结点中的指针域来指示，使得**插入和删除数据元素时不用移动数据元素**。

**缺点：**

- 存储密度小

  - 每个结点都需要额外的空间来存放指针。
  - 当结点的数据域所占的空间较小时，指针域所占的空间比重会格外的大。

- 链式存储结构是**非随机存取**结构

  - 对任意结点的操作都要通过头指针开始，顺着指针链找到该结点。
  - 增加了算法的复杂度。

  

## 5.顺序表和链表比较

|            | 顺序表                                                       | 链表                                               |
| ---------- | ------------------------------------------------------------ | -------------------------------------------------- |
| 存储空间   | 预先分配，会导致**空间闲置或溢出**                           | 动态分配，不会出现空间闲置和溢出的现象             |
| 存储密度   | 不用为表示逻辑结构而增加额外的开销，存储密度为100%           | 需要借助指针来表示逻辑结构，存储密度小于1          |
| 存取元素   | 随机存取（随意存取），按位置访问元素的时间复杂度为O(1)       | 顺序存取，按位置访问元素的时间复杂度为O(n)         |
| 插入、删除 | 需要移动表中元素，时间复杂度为O(n)                           | 不需要移动元素，确定位置后，时间复杂度为O(1)       |
| 适用情况   | 1. 表长变化不大，且能事先确定变化的范围。<br />2. 很少插入和删除元素，且经常按照序号访问数据元素。 | 1. 长度变化较大。<br />2. 频繁进行插入和删除操作。 |



## 6.线性表间的操作

### 6.1 线性表的合并

**问题描述：**

- 假设两个线性表La和Lb分别表示两个集合A和B。
- 现要求线性表合并，合并后表示的集合A=A∪B。

例如：

- 合并前：La = (7, 5, 3, 11)、Lb = (2, 6, 3)

- 合并后：La = (7, 5, 3, 11, 2, 6)

---

**算法步骤：**

- 依次取出Lb中的数据元素
- 查询La中是否也有该数据元素
  - 若La中没有该数据元素，则将该数据元素插入到La的末尾。
  - 若La中存在该数据元素，则不做任何操作。

---

**具体实现：**

```c++
void union(List &La, List &Lb){
    // 得到两线性表长度，用于for循环
    int La_len = ListLength(La);
    int Lb_len = ListLength(Lb);
    for(int i=1;i<=Lb;i++){
        // 依次取出Lb中的元素
        ElemType e;
        GetElem(Lb, i, e)
            
        // 查询取出的元素（Lb中的）是否La中已经存在
        // 若La中不存在该元素，则将该元素插入到La的末尾
        // 若La中已存在，则跳过该元素，不做任何操作
        if(!Locate(La, e)) ListInsert(La, ++La_len, e);
    }
}
```

---

**时间复杂度：**

- 该算法首先需要遍历Lb（依次取出Lb中各数据元素），然后又需要遍历La（将取出的元素逐个与La中的数据元素比较）。
- 时间复杂度为O( ListLength(La) * ListLength(Lb) )



### 6.2 有序表的合并

**问题描述：**

- 已经线性表La和Lb中的数据元素按照非递减（递增或者大小相同）的顺序排列。
- 现要求将两线性表合并为一个新的线性表Lc，且新线性表中的数据元素依然按照非递减的舒徐排列。

例如：

- 合并前：La = (1, 7, 8)、Lb = (2, 4, 6, 8, 10, 11)。
- 合并后：Lc = (1, 2, 4, 6, 7, 8, 8, 10, 11)。

---

**算法步骤：**

- **初始化**新的线性表Lc；
- **依次摘取**La、Lb中数值较小的数据元素，直到有一个线性表的数据元素被摘取完；
- 将剩余未被摘取完的线性表的中数据元素全部放入Lc中。

---

**具体实现：**

用顺序表实现：

```c++
void MergeList_Sq(SqList La, SqList, Lb, SqList &Lc){
    // 定义两指针，初始分别指向La、Lb的数组开头
    ElemType *pa = La.elem;
    ElemType *pb = Lb.elem;
    
    // 初始化Lc
    Lc.length = ListLength(La) + ListLength(Lb);  ;
    Lc.elem = new ElemType[Lc.length];
    pc = Lc.elem;
        
    // 计算La、Lb最后一个数据元素的地址，用于循环终止的条件
    ElemType *pa_last = La.elem + La.length - 1;
    ElemType *pb_last = Lb.elem + Lb.length - 1;
    
    // 依次摘取La、Lb中数值较小的数据元素，放入Lc中
    // 当其中一个线性表的元素 被摘取完 时，退出循环
    while(pa <= pa_last && pb <= pb_last){
        if(*pa < *pb) *pc++ = *pa++;  
        else *pc++ = *pb++;
    }
    
    // 将剩余未摘取完的线性表（La、Lb）的数据元素都存入Lc中
    while(pa <= pa_last) *pc++ = *pa++;
    while(pb <= pb_last) *pc++ = *pb++;   
}
```



用链表实现：

```c++
void MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc){
    // 定义三指针
    // 初始pa、pb分别指向La、Lb的首元结点
    // pc指向Lc的头结点
    LinkList pa = La->next;
    LinkList pb = Lb->next;
    LinkList pc = Lc;  // 或者 LinkList pc = La;  直接将La的地址拿过来充当Lc的地址了
    
    while(pa && pc){
        if(pa->data < pb->data){
            // 若pa指向数据元素较小，则插入到pc结点的后边
            // 随后pc移动到该结点（pc向后移动一个结点），等待下个结点的插入
            pc->next = pa;
            pc = pc->next;
            // pa向后移动，用于下一次的比较
            pa = pa->next;
        }
        else{
            // 与上述处理类似
            pc->next = pb;
            pc = pc->next;
            pb = pb->next;
        }
    }
    
    // 将为摘取完的链表 直接插入到Lc末尾
    pc->next = pa?pa:pb;
    
    // 此时La中和Lb中的数据结点都被接入Lc中，只剩下空的头结点，将其删去
    delete La;  // 如果上面令 pc = La; 则这时不能deleta La，只需delte Lb就可以
    delete Lb;  
}
```

---

**算法复杂度：**

- 使用顺序表时

  - 时间复杂度：要分别遍历过La、Lb，因此时间复杂度为O( ListLength(La) + ListLength(Lb) )
  - 空间复杂度：需要一个新的空间存放Lc，则空间复杂度也为O( ListLength(La) + ListLength(Lb) )

- 使用链表时

  - 时间复杂度：同样需要遍历过La、Lb，因此时间复杂度为O( ListLength(La) + ListLength(Lb) )
  - 空间复杂度：不需要开辟新的空间。

  

## 7.案例

## 7.1 一元多项式运算

**描述：**

　　一元多项式的运算包括：加、减和乘运算。

---

**思路：**

- 使用一顺序表来表示一多项式
  - 表中一个数据元素代表多项式中的一项；
  - 数据元素的下标代表该项的次数；
  - 数据元素的数值代表该项的系数。

例如：

- 顺序表：SqList = {3, 4, -8, 6}
- 代表多项式：3 + 4x - 8x^2^ + 6x^3^

---

**实现：**

```c++
#include <iostream>
#include "polynomial.h"

#define MAXSIZE 100

// 定义一个多项式结构体（顺序表）
typedef struct polynomial{
    int *coef;
    int length;
}Pol; 

Status InitPolynomial(Pol &L){
    // 初始化多项式
    L.coef = new int[MAXSIZE];
    if(!L.coef) return ERROR;
    L.length = 0;
    return OK;
}                                                                                                                                                                                                                       void CreatePolynomial(Pol &L){
    // 接受用户输入，创建多项式
    int max_num = 1;  // 用于保存用户输入的多项式的项数
    std::cout << "请输入多项式的项数（最多100项）" << std::endl;
    std::cin >> max_num ;
    InitPolynomial(L);
    for(int i=0;i<max_num;i++){
        std::cout << "请输入第" << i+1 << "项的系数" << std::endl;
        std::cin >> L.coef[i];
        L.length++;
    }
}

void PresentPolynomial(Pol &L){
    // 根据顺序表中内容打印多项式
    std::cout << L.coef[0];
    std::cout << " + " << L.coef[1] << "x";
    for(int i=2;i<L.length;i++){
        if(L.coef[i] == 0) continue;
        std::cout << " + " << L.coef[i] << "x^" << i;
    }
    std::cout << std::endl;
}

Pol AddPolynomial(Pol &La, Pol &Lb){
    // 多项式加法
    Pol Lc;
    InitPolynomial(Lc);
    int *pa = La.coef;
    int *pa_last = La.coef + La.length - 1;
    int *pb = Lb.coef;
    int *pb_last = Lb.coef + Lb.length - 1;
    while(pa <= pa_last && pb <= pb_last){
        Lc.coef[Lc.length++] = *pa++ + *pb++;
    }
    while(pa <= pa_last) Lc.coef[Lc.length++] = *pa++;
    while(pb <= pb_last) Lc.coef[Lc.length++] = *pb++;
    
    // 打印加法结果
    std::cout << "\t";
    PresentPolynomial(La);
    std::cout << "+\t";
    PresentPolynomial(Lb);
    std::cout << "\t-----------------------------------------------" << std::endl;
    std::cout << "=\t";
    PresentPolynomial(Lc);
    return Lc;
}

int main(){
    Pol pol_1, pol_2;  // 定义两个多项式
    
    // 分别创建这两个多项式
    CreatePolynomial(pol_1);  
    CreatePolynomial(pol_2);
    
    // 进行两个多项式的加法
    AddPolynomial(pol_1, pol_2);
    return 0;
}
```



## 7.2 稀疏多项式运算



# 三、栈和队列

## 1.定义

- 栈和队列时两种常用的、重要的数据结构；
- 栈和队列是限定插入和删除只能在表的“端点”进行的线性表
  - “端点”即线性表的两头；
  - 栈和队列是插入和删除位置受限的线性表；
  - 或者说栈和队列是线性表的子集。



## 2.栈

### 2.1 定义

- 栈是一个特殊的线性表，是限定仅在一端（通常是表尾）进行插入和删除操作的线性表。
- **逻辑结构**与线性表相同，数据元素之间为一对一的关系。
- **存储结构**用顺序栈或链栈存储均可，但顺序栈更常见。

---

**特点：**

- 后进先出（Last In First Out），简称LIFO。
- 与线性表的唯一区别是运算规则不同
  - 线性表为随机存取；
  - 栈为后进先出原则。

---

**相关概念：**

- 栈顶（Top）：表尾（即a~n~端）。
- 栈底（Base）：表头（即a~1~端）。
- **入栈（Push）：**插入元素到栈顶。
- **出栈（Pop）：**从栈顶删除最后一个数据元素。

### 2.2 基本操作

InitStack(&S)

操作结果：构造一个空栈。

DestroyStack(&S)

初始条件：栈S已存在。

操作结果：栈S被销毁。

ClearStack(&S)

初始条件：栈S已存在。

操作结果：将S清为空栈。

---

StackEmpty(S)

初始条件：栈S已存在

操作结果：若栈S为空栈，返回TRUE。否则返回FALSE。

StackLength(s)

初始条件：栈S已存在。

操作结果：返回S的元素个数，即栈的长度。

---

GetTop(S, &e)

初始条件：栈S已存在。

操作结构：用e返回S的栈顶元素。

Push(&S, e)

初始条件：栈S已存在。

操作结果：插入元素e到栈顶。

Pop(&S, &e)

初始条件：栈S已存在且非空。

操作结果：删除S的栈顶元素a~n~（栈顶元素出栈），并用e返回其值。

### 2.3 顺序栈

#### 2.3.1 存储结构定义

```c++
#define MAXSIZE 100
typedef struct{
    ElemType *base;  // 栈底指针
    ElemType *top;  // 栈顶指针
    int stacksize;  // 栈可用最大容量
}SqStack;
```

**相关概念：**

- 上溢（overflow）：**栈已经满**，又要压入元素。
- 下溢（underflow）：**栈已经空**，还要弹出元素。
  - 上溢是一种错误，使问题的处理无法进行；
  - 而下溢是一种结束条件，即问题处理结束。
- 空栈：base == top
- 栈满：top - base == stackszie

**注意：**

- 为了方便操作，**栈顶指针**一般**指向栈顶元素之上**的那个元素。

#### 2.3.2 顺序栈初始化

　　为栈分配数组空间，并令base指针和top指针指向栈底。

```c++
Status InitStack(SqStack &S){
    S.base = new ElemType[MAXSIZE];
    if(!S.base) return ERROE;
    S.top = S.base;  // 开始为空栈，空栈时top指针等于base指针
    S.stacksize = MAXSIZE;
    return OK;
}
```

#### 2.3.3 销毁顺序栈

　　销毁栈空间，并令top和base指针指向空，staksize=0。

```c++
Status DestoryStack(SqStack &S){
    if(S.base){
	    delete S.base;
        S.stacksize = 0;
        S.base = S.top = NULL;
    } 
    return OK;
}
```

#### 2.3.4 清空顺序栈

　　令栈顶指针指向栈底，表示此时栈为空栈，达到清空栈的目的。

```c++
Status ClearStack(SqStack &S){
    S.top = S.base;
    return OK;
}
```

#### 2.3.5 顺序栈是否为空

　　判断栈顶指针是否等于栈底指针，若等于则为空表，否则不为空表。

```c++
Status StackEmpyty(SqStack S){
	if(S.base == S.top) return TRUE;
    return FALSE;
}
```

#### 2.3.6 顺序栈长度

　　栈顶指针和栈底指针的差值 就是栈的长度。

```c++
int StackLength(SqStack S){
	return S.top - S.base;
}
```

#### 2.3.7 取栈顶元素

```c++
void GetElem(SqStack S, &e){
    e = *S.top;
}
```

#### 2.3.8 入栈

　　首先判断栈是否已满，若不满，则元素入栈。

```c++
Status Push(SqStack &S, e){
    if(S.top - S.base == S.stacksize) return ERROR;
    *S.top++ = e;
    return OK;
    
    
}
```

#### 2.3.9 出栈

　　首先判断栈是否已空，若不空，则元素出栈。

```c++
Status Pop(SqStack &S, &e){
    if(S.top == S.base) return ERROR;
    e = *--S.top;
    return OK;
}
```

### 2.4 链栈

#### 2.4.1 存储结构定义

```c++
typedef struct StackNode{
    ElemType data;
    struct StackNode *next;
}StackNode, *LinkStack;
```

**注意：**

- 链表的头指针就是栈顶指针；
- 链栈不要头结点；
- 基本不存在栈满的情况；
- 空栈相当于头指针为空；
- 插入和删除只在栈顶执行。

#### 2.4.2 链栈初始化

　　头指针指向空，完成初始化。

```c++
Status InitStack(LinkStack &S){
    S = NULL;
    return OK;
}
```

#### 2.4.3 销毁链栈

　　与销毁单链表类似，顺着链表一路delete过去。

```c++
Status DestoryStack(LinkStack &S){
    LinkStack p = S;
    while(S){   
        S = S->next;
        delete p;
		p = S;
    }
    return OK;
}
```

#### 2.4.4 清空链栈

　　与销毁链栈类似，一路delete过去，最后令S指向空。

```c++
Status ClearStack(LinkStack &S){
    LinkStack p = S;
    LinkStack q = p;
    
    while(q){
        q = q->next;
        delete p;
        p = q;
    }
    S->next = NULL;
    return OK;
}
```

#### 2.4.5 链栈是否为空

　　判断头指针S是否指向空，若为空，则为空栈。

```c++
Status StackEmpty(LinkStack S){
    
    if(S==NULL) return TRUE;
    return FALSE
}
```

#### 2.4.6 链栈长度

　　依次访问链栈中每个结点，记录链栈的长度。

```c++
int StackLength(LinkStack S){
    LinkStack p = S;
    int count = 0;
    while(p){
        count++;
        p = p->next;
    }
    return count;
}
```

#### 2.4.7 取栈顶元素

　　若链表不为空，则返回头指针执行的数据元素（头指针指向栈顶）。

```c++
Status GetTop(LinkStack S, &e){
    if(!S) e = S->data;
    return OK;
}
```

#### 2.4.8 入栈

　　创建新结点，并为其赋值新的数据元素。随后将该结点插入到链表的头部。

```c++
Status Push(LinkStack &S, e){
    // 创建新结点，并为其赋值
    LinkStack p = new LinkNode;
    p->data = e;
    
    // 将新结点插入到头部
    p->next = S;
    S = p;
    return OK;
}
```

#### 2.4.9 出栈

　　    定义一辅助指针p指向头结点，并令头结点指向下一结点，随后删除p指向的原头结点

```c++
Status Pop(LinkStack &S, &e){
    if(S == NULL) return ERROR;
    // 保存下要删除的结点的数据元素
    e = S->data;
 	
    // 定义一辅助指针p指向头结点，并令头结点指向下一结点
    // 随后删除p指向的原头结点
    LinkStack p = S;
    S = S->next;
    delete p;
    return OK;
}
```



## 3.队列

### 3.1 定义

- 队列是一个操作受限的线性表。
  - 仅能在**表尾进行插入操作**；
  - 仅能在**表头进行删除操作**。

---

**特点：**

- FIFO（First In First Out），先进的元素先出。

---

**相关概念：**

- 队尾（Rear）：表尾，即a~n~端。
- 队头（Front）：表头，即a~1~端。
- 入队：插入元素到队尾。
- 出队：从对头删除元素。

### 3.2 基本操作

InitQueue(&Q)

操作结果：构造空队列Q。

DestoryQueue(&Q)

初始条件：队列Q已存在；

操作结果：队列Q被销毁。

ClearQueue(&Q)

初始条件：队列Q已存在；

操作结果：队列Q被清空。

---

QueueEmpty(S)

初始条件：队列Q已存在；

操作结果：若Q为空队列，则返回TRUE，否则返回FALSE。

QueueLength(S)

初始条件：队列Q已存在；

操作结果：返回Q的元素个数，即队列的长度。

---

GetHead(Q)

初始条件：Q为非空队列；

操作结果：返回Q的对头元素。

EnQueue(&Q, e)

初始条件：队列Q已存在

操作结果：出入元素e为Q的新的队尾元素。

DeQueue(&Q)

初始条件：Q为非空队列

操作结果：删除Q的队头元素，并用e返回其值。

### 3.3 顺序队

#### 3.3.1 循环队列

普通顺序队列存在假溢出问题，可以用循环顺序队列来解决。

---

**存在问题：**

- **真溢出**：
  - 若front = 0; rear = MAXQSIZE;
  - 此时再入队会发生数组溢出，为**真溢出**。
- **假溢出**(假上溢)：
  - 若front != 0; rear = MAXQSZIE;
  - 此时再入队也会发生数组溢出，为假溢出；
  - 因此队头并不在分配空间的首部，**队头之前的空间被未被使用**。

---

**解决办法：**

1. 每次出队，将队中元素依次向队头方向移动。
   - 缺点：浪费时间。每次出队，队中元素都要移动。
2. 将队空空间设想成一个循环的表。
   - 即分配给队列的**m个存储单元可以循环使用**。
   - 当rear为MAXQSIZE时，若空间的开始端空着，又可以从头使用空着的空间。
   - 当front为MAXQSIZE时，也是一样。

---

**实现循环方法：**

目的：

- 假想base[0]接在bases[MAXQSIZE-1]之后
- 当 `front/rear == MAXSIZE` 时，`front/rear = 0`。

实现：

- 利用模运算（mod，C语言中：%）

  - 插入元素：

    ```c++
    Q.base[Q.rear] = x; 
    Q.rear = (Q.rear + 1) % MAXSIZE
    ```

  - 删除元素：

    ```c++
    x = Q.base[Q.front]; 
    Q.front = (Q.front + 1)%MAXSIZE
    ```

---

**队空、队满区分：**

- 循环顺序队列下：队空与队满时，都为front == rear，无法区分。
- 解决方案：
  1. 另外**设一个标志**以区别队空、队满。
  2. 另设一个变量，**记录元素个数**。
  3. **少用一个元素空间**（推荐）。
- 若少用一个元素空间：
  - 队空标志：`front == rear`。
  - 队满对标：`(rear + 1) % MAXQSZIE == front`。

#### 3.3.2 循环队列存储结构定义

```c++
#define MAXQSIZE 100
typedef struct{
	QElemType *base;	// 初始化的动态分配存储空间
	int front;			// 头指针
	int rear;			// 尾指针
}SqQueue;
```

#### 3.3.3 循环队列初始化

　　为队列分配空间，并将 `front` 和 `rear` 都置为0。

```c++
Status InitQueue(SqQueue &Q){
    Q.base = new QElemType[MAXQSIZE];
    if(!Q.base) return OVERFLOW;
    Q.front = Q.rear = 0;
    return OK;
}
```

#### 3.3.4 求队列长度

　　如果是普通队列，队列长度就是 `Q.rear - Q.front`。循环队列就要在差值上加上 MAXQSIZE 后再对 MAXQISIZE 取余。

```c++
Status QueueLength(SqQueue &Q){
    return (Q.rear + MAXQSIZE - Q.front) % MAXQSIZE;
}
```

#### 3.3.5 取队头元素

　　先判断队列是否为空，若不为空，则返回front指向的数据元素。

```c++
Status GetHead(SqQueue &Q){
    if(Q.front == Q.rear) return ERROR;
    return Q.base[Q.front];
}
```

#### 3.3.6 入队

　　先判断队列是否已满，若没满，则将元素插入到rear指向的空间，并且rear指针循环前进1。

```c++
Status EnQueue(SqQueue &Q, e){
    if((Q.rear+1) % MAXQSIZE == Q.front) return ERROR;
    Q.base[Q.rear] = e;
    Q.rear = (Q.rear+1) % MAXQSIZE;
    return OK;
        
}
```

#### 3.3.7 出队

　　先判断队列是否为空，若不为空，则先将front指向的数组元素保存在变量e中，再将front指针循环前进1。

```c++
Status DeQueue(SqQueue &Q, ElemType &e){
    if(Q.rear == Q.front) return ERROR;
    e = Q.base[front];
    Q.front = (Q.front+1) % MAXQSIZE;
    return OK;
}
```

### 3.4 链队

#### 3.4.1 存储结构定义

```c++
typedef struct QueueNode{
    QElemType data;
    struct QueueNode * next;
}QueueNode, *QueuePtr;

typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue
```

**相关概念：**

- 链队有两个指针分别指向队尾和队头。
- 链队的链表**带头结点**。

- 队空标志：Q.front == Q.rear。

#### 3.4.2 链队初始化

　　生成一个新结点（头结点），并令front指针和rear指针都指向该结点。

```c++
Status InitQueue(LinkQueue Q){
    Q.front = Q.rear = new QueueNode;
    if(!Q.front) return OVERFLOW;
    Q.front->next = NULL;
    return OK;
}
```

#### 3.4.3 销毁链队

　　与销毁链表类似，从头结点开始，定义一辅助指针用于记录要销毁的结点。销毁后，辅助指针和头指针向后移动，依次销毁各个结点。

```c++
Status DestoryQueue(LinkQueue Q){
    LinkQueue p = Q.front;
    while(p){
        Q.front = Q.front->next;
        delete p;
        p = Q.front;  
    }
    Q.rear = Q.front = Null;
    return OK;
}
```

#### 3.4.4 取队头元素

　　返回队头指针指向的数据元素。

```c++
Status getTop(LinkQueue Q, QElemType &e){
    if(Q.front == Q.rear) return ERROR;  // 如果队头指针和队尾指针相等，则为空队，返回错误
    return Q.front->next->data;
}
```

#### 3.4.5 入队

- 创建一个新的链队结点，用于保存要入队的数据元素；
- 随后将该新结点插入到链队尾部（由队尾指针指向）；
- 插入后更新队尾指针指向新插入的结点。

```c++
Status EnQueue(LinkQueue Q, QElemType e){
    // 创建一个新的链队结点，并为其赋值
    QueuePtr p = new QueueNode;
    p->data = e;
    p->next = NULL;
    
    // 将新结点插入到队尾，新结点为新的队尾结点
    Q.rear->next = p;
    Q.rear = p;
    return OK;
}
```

#### 3.4.6 出队

- 判断队伍是否已经为空；
- 若队伍不为空则数据元素出队；
- 若要出队的数据元素为队尾元素，则代表此时队中只有一个数据元素
  - 则令 `Q.rear` 指向头结点( `Q.front` )，代表空队。

```c++
Status DeQueue(LinkQueue Q, QElemType &e){
    if(Q.front == Q.rear) return ERROR;  // 如果为空队，则无法出队
    QueuePtr p = Q.front->next;  // 定义辅助结点，指向首元结点，即要出队的元素
    Q.front->next = p->next;  // 令新的队头为原队头的后一个
    
    // 如果要出队的元素已经是队尾，即该元素为队中最后一个元素，则改动队尾指针指向头指针，代表空队
    if(Q.rear == p) Q.rear = Q.front;
    
    // 将出队的数据元素保存在e中，随后该元素出队
    e = p->data;  
    delete p;  
     
    return OK;
}
```





# 四、串、数组和广义表





# 五、树



## 3. 二叉树的存储结构

### 3.1 线性存储结构



# 六、图

## 1. 图的定义和概念

### 1.1 图的定义

图是由顶点和边构成的**二元组**，数学表示为
$$
G = (V, E)
$$
其中：

- G：graph，图

- V：vertex，表示顶点；
- E：edge，表示边。

### 1.2 图的分类

- **无向图**：每条边都没有方向性，如下图G1。

- **有向图**：每条边都有方向性，如下图G2。
  - **弧**：有方向的边也称作弧。

<img src="图片\有向图与无向图例子.png" style="zoom: 50%;" />

- **完全图**：任意两个节点都有一条边相连。

  - **有向完全图**：当有n个顶点时，共有 $n(n-1)/2$ 条边；
  - **无向完全图**：当有n个顶点时，共有 $n(n-1)$ 条边。

  <img src="图片\无向完全图与有向完全图例子.png" style="zoom:67%;" />

- **稀疏图**：有很少的边或者弧的图（$e<n \log n$，其中 $e$ 为边的数量，$n$为顶点的数量）。
- **稠密图**：有较多边或者弧的图。
- **网**：边（或者弧）带权的图。

### 1.3 相关概念

- **邻接**：有边（或者弧）相连的**两个顶点的关系**。

  - 无向图中：存在 $(v_i, v_j)$，则称 $v_i$、$v_j$ 互为邻接点。
  - 有向图中：存在 $\left \langle v_i, v_j \right \rangle$，则称 $v_i$ 邻接到 $v_j$，$v_j$ 邻接于 $v_i$。

- **关联（依附）**：边（或者弧）与顶点之间的关系。

  - 若存在 $(v_i, v_j)$或者$\left \langle v_i, v_j \right \rangle$，则称该边关联于 $v_i$、$v_j$。

- **顶点的度**：与该顶点相关联的边的数目，记为 $TD(v)$

  - 在有项图中，顶点的度等于其**入度**和**出度**之和。

  - **入度**：以顶点 $v$ 为终点的有向边的条数，记作 $ID(v)$；

  - **出度**：以顶点 $v$ 为始点的有向边的条数，记作 $OD(v)$。

  - 例如：上图中G1、G2各顶点的度为

    <table>
        <tr>
            <th rowspan=2></th>
            <th colspan=5 align="center">G1</th>
            <th colspan=4 align="center">G2</th>
        </tr>
        <tr align="center">
            <th>v1</th>
            <th>v2</th>
            <th>v3</th>
            <th>v4</th>
            <th>v5</th>
            <th>v1</th>
            <th>v2</th>
            <th>v3</th>
            <th>v4</th>
        </tr>
        <tr align="center">
            <th>度</th>
            <td>2</td>
            <td>3</td>
            <td>3</td>
            <td>3</td>
            <td>3</td>
            <td>3</td>
            <td>1</td>
            <td>2</td>
            <td>2</td>
        </tr>
        <tr align="center">
            <th>入度</th>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td>2</td>
            <td>0</td>
            <td>0</td>
            <td>2</td>
        </tr>
        <tr align="center">
            <th>出度</th>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td>1</td>
            <td>1</td>
            <td>2</td>
            <td>0</td>
        </tr>
    </table>

  - 特别地，当一个有向图有的只有一个顶点的入度为0，其余顶点的入度均为1，则此时的有向图为一棵**有向树**。

---

- **路径**：接续的边构成的**顶点序列**。

- **路径长度**：路径上的边（或者弧）的数目或者权值之和。

- **简单路径：**除第一个顶点和最后一个顶点可以相同外，其余顶点均不相同的路径。

- **回路（环）**：第一个顶点和最后一个顶点相同的路径。

- **简单回路（简单环）：**除第一个顶点和最后一个顶点相同外，其余顶点均不相同的路径。

  <img src="图片\各种路径例子.png" style="zoom:67%;" />

---

- **连通图**：在无向图 $G=(V,\{E\})$ 中，若对任何两个顶点 $v_1$、$v_2$ ，都存在从 $v_1$到$v_2$的路径，则称图 $G$ 为连通图。
- **强连通图**：在有向图 $G=(V,\{E\})$ 中，若对任何两个顶点 $v_1$、$v_2$ ，都存在从 $v_1$到$v_2$的路径，则称图 $G$ 为强连通图。

<img src="图片\连通图与非连通图例子.png" style="zoom: 67%;" />

- **子图**：

  - 设有两个图：$G = (V, \{ E \})$，$G_1 = (V_1, \{ E_1 \})$，
  - 若 $V_1 \subseteq V$，$E_1 \subseteq E$，则称 $G_1$ 是 $G$ 的子图。
  - 例如：下图中(b)、(c) 是 (a)的子图。

  <img src="图片\子图例子.png" style="zoom:67%;" />

---

- **极大连通子图**：该子图是 $G$ 的子图，将 $G$ 的任何不在该子图的顶点加入，子图不再连通。

- **连通分量**：无向图 $G$ 的*极大连通子图* 称为连通分量。

- **强连通分量**：有向图的*极大连通子图* 称为强连通分量。

  <img src="图片\连通分量.png" style="zoom:67%;" />

- **极小连通子图**：该子图是 $G$ 的连通子图，在该子图中删除任何一条边都使该子图不再连通。
- **生成树**：包含无向图 $G$ 所有顶点的极小连通子图。
- **生成森林**：对非连通图，由连通分量的生成树的集合。

<img src="图片\生成树.png"  />



## 2. 图的类型定义



## 3. 图的存储结构

图没有顺序存储结构，但可以用二维数组来表示元素间的关系

- 数组表示法：
  - 邻接矩阵。
- 链式表示法：
  - 邻接表；
  - 邻接多重表；
  - 十字链表。

### 3.1 邻接矩阵

#### 3.1.1 邻接矩阵的定义 

邻接表示法需要有以下两个数组：

- **顶点表**：一维数组，记录各顶点信息。

  - 设图 $G = (V, E)$ 有 $n$ 个顶点，则顶点表Vexs[n]为：

  - |    i    |   0   |   1   |   2   | ...  |   n   |
    | :-----: | :---: | :---: | :---: | :--: | :---: |
    | Vexs[i] | $V_0$ | $V_1$ | $V_3$ | ...  | $V_n$ |

- **邻接矩阵**：二维数组，表示各顶点的关系。

  - 邻接矩阵G.arcs[n][n\]定义为：
    $$
    \text{G.arcs[i][j]} = 
    \begin{cases}
    1, & 如果\left \langle i, j\right \rangle \in E 或者 (i, j) \in E  \\
    0, & 否则
    
    \end{cases}
    $$

#### 3.1.2 无向图的邻接矩阵

设一**无向图**为：

<img src="图片\邻接矩阵举例_无向图.png" style="zoom:50%;" />

则其**邻接矩阵**为：

<img src="图片\邻接矩阵举例_无向图2.png" style="zoom: 50%;" />

- 无向图的邻接矩阵是对称矩阵；
- 顶点 $v_i$ 的度 = 第 $i$ 行（列）中1的个数；
- 特别地，对于完全无向图，其邻接矩阵的对角元素全为0，其余元素全为1。

#### 3.1.3 有向图的邻接矩阵

设有一**有向图**：

<img src="图片\邻接矩阵举例_有向图.png" style="zoom:50%;" />

其**邻接矩阵**为：

<img src="图片\邻接矩阵举例_有向图2.png" style="zoom:50%;" />



- 第 $i$ 行的元素表示以顶点 $v_i$ 为结尾的弧（即出度边）；
  - 顶点 $v_i$ 的出度 = 第 $i$ 行元素的和。
- 第 $j$ 列的元素表示以顶点 $v_j$ 为开始的弧（即入度边）。
  - 顶点 $v_j$ 的入度 = 第 $j$ 行元素的和。
- 顶点 $v_i$ 的度 = 第 $i$ 行元素的和 + 第 $i$ 行元素的和。

**注意**：

- 有向图的邻接矩阵可能不是对称矩阵。

#### 3.1.4 网（有权图）的邻接矩阵

设一网为：

<img src="图片\邻接矩阵举例_网.png" style="zoom:50%;" />

其邻接矩阵为：

<img src="图片\邻接矩阵举例_网2.png" style="zoom:50%;" />

- 类例于有向图：
  - 第 $i$ 行的元素表示以顶点 $v_i$ 为结尾的弧（即出度边）。
  - 第 $j$ 列的元素表示以顶点 $v_j$ 为开始的弧（即入度边）。
- 数值为弧的权值
  - 当两顶点不存在弧时，权值为 $\infty$。

#### 3.1.5 邻接矩阵的实现

如3.1.1所述，使用邻接矩阵表示一个图需要使用两个数组：顶点表（一维数组）、邻接矩阵（二维数组）。因此可以定义如下结构体：

```c++
#define MaxInt 32767   // 最大整数，表示无穷大
#define MVNum  100     // 最大顶点数
typedef char VertexType;  // 定义顶点类型，比如说是char
typedef int ArcType;      // 定义权值类型，比如说是int

typedef struct{
    VertexType vexes[MVnum];  // 顶点表
    ArcType arcs[MVnum][MVnum];  // 邻接矩阵
    int vertex_num, arc_num;  // 顶点数 与 边数
}AMGraph;  // Adjacency Matrix graph
```

---

**创建无向网**

```c++
Status createUDN(AMgraph &G){
	// 输入总顶点数和总边数
	cin >> G.vertex_num >> G.arc_num;
    
    // 将顶点信息存入顶点表中
    for(int i=0; i<G.vertex_num; i++)
    	cin >> G.vexes[i];
    
    // 初始化邻接表(所有边的权值为无穷大)
    for(int i=0; i<G.vertex_num; i++)
        for(int j=0; j<G.vertex_num; i++)
            G.arcs[i][j] = MaxInt;
    
    // 构造邻接矩阵
    for(int i=0; i<G.arc_num; i++){
		VertexType v1, v2;
		ArcType w;
		cin >> v1 >> v2 >> w;
		int v1_index = locate_vex(G, v1);
		int v2_index = locate_vex(G, v2);
		G.arcs[v1_index][v2_index] = w;
		G.arcs[v2_index][v1_index] = w;
	}
}

// 给定顶点名称，找到顶点的索引
int locate_vex(AMGraph G, VertexType v){
        for(int i=0; i<G.vertex_num; i++)
                if (G.vexes[i] == v) return i;
        return  -1;
}

```

---

其他类型的图的邻接矩阵都只要在无向网基础上更改一点，就可以得到。

- 创建**无向图**（网 -> 图）：
  - 在初始化邻接矩阵时，w均为0；
  - 构造邻接矩阵时，w为1。

- 创建**有向网**（无向 -> 有向）：
  - 邻接矩阵是非对称矩阵；
  - 只执行`G.arcs[v1_index][v2_index] = w;`；
  - 而不执行`G.arcs[v2_index][v1_index] = w;`。
- 创建**有向图**（网 -> 图，无向 -> 有向）：
  - 在初始化邻接矩阵时，w均为0；
  - 构造邻接矩阵时，w为1。
  - 只执行`G.arcs[v1_index][v2_index] = 1;`；
  - 而不执行`G.arcs[v2_index][v1_index] = 1;`。

#### 3.1.6 邻接矩阵的优缺点

**优点**：

- 直观、简单、好理解；
- 方便检查任意一对顶点之间是否存在边；
- 方便查找任意顶点的所有邻接点；
- 方便计算任一顶点的度：
  - 无向图：对应行的元素之和；
  - 有向图：
    - 出度：对应行的非零元素的个数；
    - 入度：对应列的非零元素的个数；
    - 度：出度 + 入度。

**缺点**：

- 不便于增加和删除顶点；
- 浪费空间；
  - 由其对于稀疏图来说；
  - 对于稠密图，邻接矩阵还是很划算的。
- 浪费时间：对于统计稀疏图的边来说。

### 3.2 邻接表

#### 3.2.1 无向图的邻接表

使用**邻接表**（adjacent list）表示图同样需要一维数组，用于保存顶点信息。不同的是，这个一维数组中的元素是一个链表的头结点。具体结构如下图所示：

<img src="图片\邻接表举例_无向图.png" style="zoom:67%;" />

- 顶点：
  - 顶点信息被保存的头结点中；
  - 多个包含顶点信息的头结点组成一个一维数组；
  - 头结点后链接表结点；
- 边：
  - 表结点中保存与**表头顶点邻接的顶点**的数组索引。
    - 如果是有向图，则是**始于表头顶点的弧指向的顶点**的数组索引。
  - 表结点的指针域指向向一个与表头顶点邻接的顶点。
  - 如果是网，则需在表结点中增加一项，用于存储该边的权值。

注意：

- 表结点的指针域指向的不是表顶点邻接的顶点，而是表头顶点邻接的顶点。
  - 因此同一表头顶点其后的**表结点顺序是不唯一的**，也意味着**邻接表不唯一**。
- 若一无向图中有 $n$ 个顶点、$e$ 条边，则其邻接表需要 $n$ 个头结点与 $2e$ 个表结点。
  - 这个特性使得邻接表适合存储稀疏图。
- 若图为无向图，则顶点 $v_i$ 的度为第 $i$ 个单链表的结点数。

#### 3.2.2 有向图的邻接表

有向图的邻接表类似于无向图的邻接表，包括一个表头数组，数组中存储着多条链表，用于保存其表头顶点的出度边。如果链表中保存的是表头顶点的入度边，则该表为逆邻接表。

<img src="图片\邻接表举例_有向图.png" style="zoom: 50%;" />

邻接表特点：

- 顶点 $v_i$ 的**出度**就是第 $i$ 个单链表中的结点个数。
- 顶点 $v_i$ 的**入度**是整个邻接表中邻接点数值是 $i-1$ 的结点个数。
  - 因此统计顶点 $v_i$ 有入度需要遍历整个邻接表，效率很低。

逆邻接表特点：

- 顶点 $v_i$ 的**入度**就是第 $i$ 个单链表中的结点个数。
- 顶点 $v_i$ 的**出度**是整个邻接表中邻接点数值是 $i-1$ 的结点个数。
  - 因此统计顶点 $v_i$ 有出度需要遍历整个逆邻接表，效率很低。

#### 3.2.3 邻接表的实现

如前所述，邻接表需要一个表头结点（顶点结点）与边结点，表头结点数组即为邻接表。

```c++
// 顶点结点
typedef struct VNode{
    VertexType vertex;  // 保存顶点信息
    struct ArcNode* first_arc;  // 指向第一个边结点
}VNode, Adj_list[MVnum];

// 边结点
typedef struct ArcNode{
    int vertex_index;  // 保存表头顶点指向的顶点的数组索引
    ArcType arc;  // 保存边的权重（用于网）
    struct ArcNode* next_arc;  // 指向下一个邻接的边结点
}ArcNode, *ArcLink;

// 邻接表
typedef struct ALGraph{
    Adj_list vexes;  // 顶点表
    int vertex_num, arc_num;  // 总顶点数与边数
}ALGraph;                                                 
```

---

下面实现**无向图邻接表**的创建：

```c++
// 根据顶点名称找到索引                                                  
int locate_vertex(ALGraph G, VertexType v){                              
    for(int i=0; i<G.vertex_num; i++){                                   
        if(G.vexes[i].vertex == v) return i;                             
    }                                                                    
    return -1;                                                           
}                                                                        
                                                                         
// 构建无向图邻接表                                                      
Status createUDG(ALGraph &G){                                            
    // 输入无向图总顶点数与边数                                          
    std::cout << "请输入无向图总顶点数与边数" << std::endl;              
    std::cin >> G.vertex_num >> G.arc_num;                               
                                                                         
    // 构造顶点表                                                        
    for(int i=0; i<G.vertex_num; i++){                                   
        std::cout << "请输入第" << i+1 << "个顶点的名称" << std::endl;   
        std::cin >> G.vexes[i].vertex;                                   
        G.vexes[i].first_arc = NULL;                                     
    }                                                                    
                                                                         
    // 构造邻接表                                                        
    for(int i=0; i<G.arc_num; i++){                                      
        // 读入关联边                                                    
        VertexType v1, v2;                                               
        std::cout << "请输入第" << i+1 << "条边关联的顶点" << std::endl; 
        std::cin >> v1 >> v2;                                            
                                                                         
        // 根据顶点名称找到索引                                          
        int v1_index = locate_vertex(G, v1);                             
        int v2_index = locate_vertex(G, v2);                             
                                                                         
        // 插入新结点                                                    
        ArcLink p = new ArcNode;                                         
        p->vertex_index = v2_index;                                      
        p->arc = 1;                                                      
        p->next_arc = G.vexes[v1_index].first_arc;                       
        G.vexes[v1_index].first_arc = p;                                 
                                                                         
        p = new ArcNode;                                                 
        p->vertex_index = v1_index;                                      
        p->arc = 1;    
        p->next_arc = G.vexes[v2_index].first_arc;   
        G.vexes[v2_index].first_arc = p;             
    }                                                
                                                     
    std::cout << "构造邻接表成功！" << std::endl;    
    return OK;                                       
}   
```

创建无向图的邻接表可以分为以下几步：

- 读取图的总顶点数与边数；
- 构造顶点表；
- 构造邻接表：
  - 依次读取一条边关联的两顶点；
  - 找到两顶点在顶点表中的索引；
  - 生成一个新的边结点；
    - 其数值是头顶点指向的顶点的索引，边的权值是1。
  - 使用头插法插入新的边结点到链表中。
  - 由于是无向图，还需再生成一个边结点，添加到另一个头顶点的链表中。

---

有向图、无向网和有向网的创建步骤只需要在**无向图创建步骤的基础上稍微改动**即可。

**有向图**邻接表的创建：

- 在构造邻接表时只生成一个边结点，并添加到头顶点的链表中。

**无向图**邻接表的创建：

- 在构造邻接表时，将边结点对应的权值修改为实际的权值。

**有向网**邻接表的创建：

- 在构造邻接表时，将边结点对应的权值修改为实际的权值。
- 在构造邻接表时只生成一个边结点，并添加到头顶点的链表中。

#### 3.2.4 邻接表特点

- 方便找到任一顶点的邻接点；
- 节约稀疏图的空间；
  - 需要 $n$ 个表头结点和 $2e$ 个边结点（每个结点至少两个域）。
- 方便计算任一顶点的度
  - 无向图：只需统计顶点链表的长度。
  - 有向图：只方便计算顶点的出度。
    - 计算有向图的任一顶点的入度需要遍历整个邻接表。
- 不方便检查任意顶点之间是否存在边。

### 3.3 十字链表

#### 3.3.1 十字链表定义

邻接表存在的缺点如图所示，对于有向图，邻接表求顶点的度比较麻烦。作为改进，十字链表整合了邻接表与逆邻接表，使得求任一顶点的出度与入度都十分容易。

<img src="图片\邻接表缺点与改进.png" style="zoom:50%;" />

**十字链表**（Orthogonal List）是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。

十字链表的结构具体如图所示：

<img src="图片\十字链表举例.png" style="zoom:67%;" />

类似于邻接表，十字链表由顶点结点（表头结点）与弧结点组成。

- **弧结点**：用于保存弧信息。
  - tail_vertex：保存弧尾关联的顶点；
  - head_vertex：保存弧头关联的顶点；
  - hlink：链接相同弧头的弧，即链接入度边；
  - tlink：链接相同弧尾的弧，即链接出度边。
- **顶点结点**：用于保存各顶点信息，并构成顶点表。
  - data：保存顶点信息；
  - first_in：记录了第一条入度边；
  - first_out：记录了第一条出度边。
- **结构上**：
  - 同一结点的出度边结点构成一行；
  - 同一结点的入度边结点构成一列；
  - 相当于**链表形式的邻接矩阵**，适用于存储稀疏图。

#### 3.3.2 十字链表实现

如前所述，十字链表由弧结点和顶点结点组成，两类结点与图结构体定义如下：

```c++
// 十字链表的顶点结点                                         
typedef struct VNode_OL{                                      
    VertexType vertex;  // 记录顶点信息                       
    struct ArcNode_OL *first_out;  // 第一个出度边            
    struct ArcNode_OL *first_in;  // 第一个入度边             
}VNode_OL, Adj_list_OL[MVnum];                                
                                                              
// 十字链表的弧结点                                           
typedef struct ArcNode_OL{                                    
    int tail_index;  // 弧尾顶点                              
    int head_index;  // 弧头顶点                              
    struct ArcNode_OL *hlink;  // 下一个同弧头的弧，即入度边  
    struct ArcNode_OL *tlink;  // 下一个同弧尾的弧，即出度边  
}ArcNode_OL, *ArcLink_OL;                                      
                                                              
// 十字链表图                                                 
typedef struct OLGraph{                                       
    Adj_list_OL vexes;                                        
    int vertex_num, arc_num;                                  
}OLGraph;                    
```

---

十字链表创建过程如下：

```c++
// 使用十字链表创建有向图
Status createDG(OLGraph &G){
    // 读取有向图的总顶点数与边数
    std::cout << "请输入有向图的总顶点数与边数" << std::endl;
    std::cin >> G.vertex_num >> G.arc_num;

    // 构造顶点表
    for(int i=0; i<G.vertex_num; i++){
        std::cout << "请输入第" << i+1 << "个顶点的名称" << std::endl;
        std::cin >> G.vexes[i].vertex;
        G.vexes[i].first_in = NULL;
        G.vexes[i].first_out = NULL;
    }

    // 构造十字链表
    for(int i=0; i<G.arc_num; i++){
        // 读入弧关联的顶点
        std::cout << "请输入第" << i+1 << "条弧关联的顶点的名称" << std::endl;
        VertexType v_tail, v_head;
        std::cin >> v_tail >> v_head;

        // 找到两个顶点的索引
        int vt_index = locate_vertex(G, v_tail);
        int vh_index = locate_vertex(G, v_head);

        // 创建顶点并插入
        ArcNode_OL *p = new ArcNode_OL;
        p->tail_index = vt_index;
        p->head_index = vh_index;
        p->tlink = G.vexes[vt_index].first_out;  // 插入顶点
        G.vexes[vt_index].first_out = p;
        p->hlink = G.vexes[vh_index].first_in;  // 插入顶点
        G.vexes[vh_index].first_in = p;
     }

     std::cout << "创建有向图成功！" << std::endl;
     return OK;
 }
```

大致步骤如下：

- 读入总顶点数与弧数；
- 构造顶点表；
- 构造十字链表：
  - 读入各条弧关联的顶点（弧尾顶点与弧头顶点）；
  - 找到弧尾顶点与弧头顶点的索引，并奖项写入弧结点中；
  - 根据关联关系，将弧结点插入到十字链表中。
    - 即修改弧结点中的hlink与tlink。

### 3.4 邻接多重表

#### 3.4.1 邻接多重表定义

**邻接多重表**（adjacent multilist）用于解决无向图邻接表的缺点：一条边会出现两次，如图为邻接多重表的结构。

<img src="图片\邻接多重表举例.png" style="zoom: 67%;" />

类似于邻接表，邻接多重表由顶点结点和边结点组成：

- 边结点：用于保存边的信息。
  - `i_vertex`、`j_vertex`：分别保存边关联的两个顶点的（在顶点表中的）索引；
  - `i_link`、`j_link`：分别链接依附于i_vertex、j_vertex的下一条边。
- 顶点结点：用于保存顶点信息，并组成顶点表。
  - `data`：顶点名称；
  - `first_edge`：链接顶点关联的第一条边

#### 3.4.1 邻接多重表实现



# 附录

```c++
// 函数结果状态宏定义
#define TRUE 	1
#define FALSE 	0
#define OK 		1
#define ERROR 	0
#define INFEASIBILE -1
#define OVERFLOW	-2

// Status 是函数的类型，其值是函数返回结果的状态码
typedef int Status;
```

